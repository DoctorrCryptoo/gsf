//******************************************************************************************************
//  VoltageLevelEnumGenerator.cs - Gbtc
//
//  Copyright © 2024, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/08/2024 - J. Ritchie Carroll
//       Generated original version of source code.
//
//******************************************************************************************************

//#define DEBUG_GENERATOR

using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

#if DEBUG_GENERATOR
using System.Diagnostics;
#endif

namespace GSF.CodeGenerators;

[Generator]
public class VoltageLevelEnumGenerator : ISourceGenerator
{
    private const string Namespace = "GSF.Units.EE";
    private const string AttributeName = $"{Namespace}.GenerateVoltageLevelsAttribute";

    private const string EnumTemplate =
        $$$"""
        // <auto-generated/>

        using System;
        using System.ComponentModel;

        namespace {{{Namespace}}};

        /// <summary>
        /// Common transmission voltage levels enumeration.
        /// </summary>
        [Serializable]
        public enum {0} : byte
        {{
           // Note: Not assigning kV level as enum value is intentional so
           // that enum value will fit within a byte. Use extension method
           // "Value()" to get actual voltage level value, e.g.:
           // (int)VoltageLevel.kV115 == 3 && VoltageLevel.kV115.Value() == 115
        {1}
        }}
        """;

    private const string EnumItemTemplate =
        """
            
            /// <summary>
            /// {0} kV.
            /// </summary>
            [Description("{0}")]
            kV{0}{1}
        """;

    public void Initialize(GeneratorInitializationContext context)
    {
    #if DEBUG_GENERATOR
        if (!Debugger.IsAttached)
            Debugger.Launch();
    #endif

        // Find specified attribute type on class declarations
        context.RegisterForSyntaxNotifications(() => new AttributeFinder<ClassDeclarationSyntax>(AttributeName));
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not AttributeFinder<ClassDeclarationSyntax> { HasCandidateAttributes: true } attributeFinder)
            return;

        foreach (AttributeSyntax attribute in attributeFinder.CandidateAttributes)
        {
            // Make sure candidate attribute is a match for the fully qualified attribute name
            if (!attributeFinder.IsMatch(context.Compilation))
                continue;

            // Get the attribute's constructor arguments
            SeparatedSyntaxList<AttributeArgumentSyntax> arguments = attribute.ArgumentList?.Arguments ?? default;

            if (arguments.Count < 2)
                continue;

            // Get the attribute's first constructor argument value, enum name
            string enumName = arguments[0].Expression.NormalizeWhitespace().ToFullString()[1..^1];

            // Get remaining param array arguments, voltage levels
            string[] voltageLevels = arguments.Skip(1).Select(argument =>
                argument.Expression.NormalizeWhitespace().ToFullString()).ToArray();

            // Generate enum and values based on attribute arguments
            StringBuilder enumItems = new();

            for (int index = 0; index < voltageLevels.Length; index++)
            {
                enumItems.AppendFormat(EnumItemTemplate, voltageLevels[index], index == 0 ? " = 1" : "");

                if (index == voltageLevels.Length - 1)
                    continue;

                enumItems.AppendLine(",");
            }

            string generatedSource = string.Format(EnumTemplate, enumName, enumItems);

            // Add the source code to the compilation
            context.AddSource($"{enumName}.g.cs", generatedSource);
        }
    }
}